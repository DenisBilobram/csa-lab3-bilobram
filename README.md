# csa-lab3-bilobram

- Билобрам Денис Андреевич, P3219
- `asm | risc | harv | mc | instr | struct | stream | port | cstr | prob1 | pipeline`
- Базовый вариант.

## Язык программирования ASM

``` bnf
<program> ::= <data_section> <text_section>

<data_section> ::= ".data" {<data_definition>}*

<data_definition> ::= <label> ":" <data_value>

<data_value> ::= <string_literal> | <number>

<string_literal> ::= <char_literal> {"," <char_literal>}*

<char_literal> ::= "'" <char> "'"

<number> ::= <digit> {<digit>}*

<text_section> ::= ".text" {<instruction>}*

<instruction> ::= <label> ":" <command> | <command>

<label> ::= <letter> {<letter> | <digit>}*

<command> ::= "MOV" <reg> "," <number>
            | "MOV" <reg> "," <reg>
            | "LOAD" <reg> "," <direct_address>
            | "LOAD" <reg> "," <indirect_address>
            | "STORE" <reg> "," <direct_address>
            | "STORE" <reg> "," <indirect_address>
            | "ADD" <reg> "," <reg> "," <reg>
            | "SUB" <reg> "," <reg> "," <reg>
            | "DIV" <reg> "," <reg> "," <reg>
            | "IDIV" <reg> "," <reg> "," <reg>
            | "MUL" <reg> "," <reg> "," <reg>
            | "INC" <reg>
            | "DEC" <reg>
            | "CMP" <reg> "," <reg>
            | "CMP" <reg> "," <number>
            | "JMP" <label>
            | "JZ" <label>
            | "JNZ" <label>
            | "HALT"
            | "OUT" <reg> "," <port>
            | "IN" <reg> "," <port>

<reg> ::= "R1" | "R2" | "R3"

<direct_address> ::= <number>

<indirect_address> ::= "(" <reg> ")"

<port> ::= <1>

<letter> ::= "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m"
           | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z"
           | "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M"
           | "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z"

<digit> ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<char> ::= <letter> | <digit> | <special_char>

<special_char> ::= "!" | "\"" | "#" | "$" | "%" | "&" | "'" | "(" | ")" | "*" | "+" | "," | "-" | "." | "/" | ":" | ";" | "<" | "=" | ">" | "?" | "@" | "[" | "\\" | "]" | "^" | "_" | "`" | "{" | "|" | "}" | "~"
```

## Описание семантики ASM

### Стратегия вычислений

#### Последовательное выполнение
Выполнение программы происходит последовательно, команда за командой, начиная с первой инструкции в секции `.text` и продолжая до встречи команды `HALT` или другой команды управления потоком, такой как `JMP` или `JNZ`.

#### Прямой и косвенный переход
- **`JMP <label>`**: Безусловный переход к указанной метке.
- **`JNZ <label>`**: Условный переход к указанной метке, если флаг Zero не установлен.

### Области видимости

#### Глобальные данные
Все данные, объявленные в секции `.data`, имеют глобальную область видимости. Это означает, что они доступны для всех инструкций в секции `.text` на протяжении всей программы.

#### Метки
Метки, используемые в секции `.text`, определяют точки в программе, к которым можно перейти с помощью команд управления потоком. Метки имеют локальную область видимости в пределах программы, но могут быть использованы для переходов из любой точки секции `.text`.

### Виды литералов

#### Числовые литералы
- **Описание**: Целые числа, используемые для инициализации данных, адресации и арифметических операций.
- **Пример**:
  ```
  CONST_ONE: 1
  MOV R1, 1000
  ```

#### Строковые литералы
- **Описание**: Последовательности символов, хранящиеся в памяти и используемые для вывода.
- **Пример**:
  ```
  HELLO: 'H', 'e', 'l', 'l', 'o', 0
  ```

## Организация памяти

### Модель памяти процессора

#### Машинное слово
- **Память данных**: 16 бит.
- **Память инструкций**: реализованна высокоуровневой структурой данных, машинное слово не определенно.

#### Варианты адресации
- **Косвенная адресация**: Адрес указывается в регистре. Формат: `(R1)` означает, что адрес содержится в регистре `R1`.
- **Прямая адресация**: Адрес указывается непосредственно. Формат: `100` означает, что данные находятся по адресу `100`.

### Механика отображения программы и данных на процессор
```
+----------------------+
|      Registers       |
+----------------------+
| R1                   |
| R2                   |
| R3                   |
+----------------------+

+-----------------------+
|   Instruction memory  |
+-----------------------+
| 00 : program start    |
| ...                   |
| n  : HALT             |
| ...                   |
+-----------------------+

+-----------------------+
|      Data memory      |
+-----------------------+
| 00 : CONST_ONE        |
| ...                   |
| l  : variable 1       |
| l+1: variable 2       |
| ...                   |
| c  : str literal      |
| ...                   |
+-----------------------+
```

#### Виды памяти и регистров, доступные программисту
- **Регистры общего назначения**: R1, R2, R3.
- **Память данных**: Используется для хранения данных, объявленных в секции `.data` и динамических данных.


## Система комад:

#### Команда `MOV`
- **Семантика**: Перемещает данные из одного регистра в другой или из числа в регистр.
- **Пример**:
  ```MOV R1, 1000    ; R1 = 1000
  MOV R2, R1      ; R2 = R1 (то есть R2 = 1000)
  ```

#### Команда `LOAD`
- **Семантика**: Загружает данные из памяти по указанному адресу в регистр.
- **Пример**:
  ```LOAD R1, (R2)   ; R1 = память[адрес, указанный в R2]
  LOAD R3, 50     ; R3 = память[адрес 50]
  ```
#### Команда `STORE`
- **Семантика**: Сохраняет данные из регистра в память по указанному адресу.
- **Пример**:
  ```STORE R1, (R2)  ; память[адрес, указанный в R2] = R1
  STORE R3, 100   ; память[адрес 100] = R3
  ```

#### Команда `ADD`
- **Семантика**: Складывает значения из двух регистров и сохраняет результат в третий регистр.
- **Пример**:
  ```
  ADD R1, R2, R3  ; R1 = R2 + R3
  ```

#### Команда `SUB`
- **Семантика**: Вычитает значение одного регистра из другого и сохраняет результат в третий регистр.
- **Пример**:
  ```
  SUB R1, R2, R3  ; R1 = R2 - R3
  ```

#### Команда `IDIV`
- **Семантика**: Выичсляет остаток от отделения первого регистра на воторой и записывает в третий регистр.
- **Пример**:
  ```
  IDIV R1, R2, R3  ; R1 = R2 % R3
  ```

#### Команда `DIV`
- **Семантика**: Целочисленно делит первый регистр на второй и сохраняет результат в третий регистр.
- **Пример**:
  ```
  DIV R1, R2, R3  ; R1 = R2 / R3
  ```

#### Команда `MUL`
- **Семантика**: Перемножает два регистра и сохраняет результат в третий регистр.
- **Пример**:
  ```
  MUL R1, R2, R3  ; R1 = R2 * R3
  ```

#### Команда `INC`
- **Семантика**: Увеличивает значение регистра на единицу.
- **Пример**:
  ```
  INC R1          ; R1 = R1 + 1
  ```

#### Команда `CMP`
- **Семантика**: Сравнивает значения двух регистров и устанавливает флаг состояния Zero, если значения равны.
- **Пример**:
  ```
  CMP R1, R2      ; Устанавливает флаг Zero, если R1 == R2
  ```

#### Команда `JMP`
- **Семантика**: Безусловный переход к указанной метке.
- **Пример**:
  ```
  JMP START       ; Переход к метке START
  ```

#### Команда `JZ`
- **Семантика**: Условный переход к указанной метке, если флаг Zero установлен.
- **Пример**:
  ```
  JZ LOOP       ; Переход к метке LOOP, если флаг Zero установлен
  ```

#### Команда `JNZ`
- **Семантика**: Условный переход к указанной метке, если флаг Zero не установлен.
- **Пример**:
  ```
  JNZ LOOP       ; Переход к метке LOOP, если флаг Zero не установлен
  ```

#### Команда `HALT`
- **Семантика**: Останавливает выполнение программы.
- **Пример**:
  ```
  HALT            ; Остановка программы
  ```

#### Команда `OUT`
- **Семантика**: Выводит данные из регистра на указанный порт.
- **Пример**:
  ```
  OUT R1, 1       ; Вывод значения из R1 на порт 1
  ```

#### Команда `IN`
- **Семантика**: Загружает данные с указанного порта в регистр.
- **Пример**:
  ```
  IN R1, 2        ; Загрузка значения с порта 2 в R1
  ```

## Транслятор


## Модель процессора

### Control Unit
![Control Unit](resources/control_unit.png)

### Data Path
![Data Path](resources/data_path.png)

### Микропрограммное управление

#### Осуществляется при помощи:
- **Control logic**: Получает микрокоманду и отправляет управляющие сигналы элементам Data Path и Control Unit.

- **Control Store**: Хранит все микропрограммы. Получает адрес микрокоманды, считывает микрокоманду и отправляет её в Control Logic.

- **μPC**: Хранит адрес текущей микропрограммы.

- **Instruction Decoder**: Декодирует команду, определяя адрес начала микропрограммы, а так же извлекает операнд из команды.

#### Микрокоманда состоит из 32 управляющих битов:

| Bit Pos      | Control Sginal          | Description                  |
|--------------|----------------|---------------------------------------|
| 0            | latch_ip       | Латчирование значения IP              |
| 1            | sel_ip         | Выбор между инкрементом IP и загрузкой операнда текущей команды |
| 2            | latch_ir       | Латчирование значения IR              |
| 3            | latch_mc_addr  | Латчирование значения μPC             |
| 4-5          | sel_mc_addr    | Выбор между инкрементом μPC, загрузкой следующей микропрограммы и обнулением μPC |
| 6            | read_mc        | Чтение микрокоманды из Control Store  |
| 7            | latch_r1       | Латчирование значения в R1            |
| 8            | latch_r2       | Латчирование значения в R2            |
| 9            | latch_r3       | Латчирование значения в R3            |
| 10-11        | sel_op_1       | Выбор первого операнда ALU            |
| 12-13        | sel_op_2       | Выбор второго операнда ALU            |
| 14-15        | operation      | Выбор операции ALU                    |
| 16           | start_decode   | Начать декодирование инструкции       |
| 17           | sel_addr       | Выбор адреса для AR                   |
| 18           | latch_addr     | Латчирование значения в AR            |
| 19           | mem_read       | Чтение из памяти                      |
| 20           | mem_write      | Запись в память                       |
| 21           | out_buf_write  | Вывод через порт указанный в OR       |
| 22           | out_buf_next   | Добавить следующее значение в буфер   |
| 23           | inp_buf_read   | Чение через порт указанный в OR       |
| 24           | inp_buf_next   | Перейти к следующему значению буфера  |
| 25           | latch_dr       | Латчирование значения в DR            |
| 26-27        | sel_r_read     | Выбор из R1-R3 на выход MUX2          |
| 28-30        | sel_r_write    | Выбор из 5 входов на выход MUX1       |
| 31           | latch_or       | Латчирование значения в OR            |

#### Значения управляюших сигналов в микрокоманде:

| Bit Pos | Value | Meaning                              |
|---------|-------|--------------------------------------|
| 0       | 1     | Защёлкнуть IP                        |
| 1       | 0     | Инкремент IP                         |
| 1       | 1     | operand -> IP                        |
| 2       | 1     | Защёлкнуть IR                        |
| 3       | 1     | Защёлкнуть μPC                       |
| 4-5     | 00    | Инкремент μPC                        |
| 4-5     | 01    | Загрузить новый адрес в μPC          |
| 4-5     | 10    | Обнулить μPC                         |
| 6       | 1     | Чтение микрокоманды по адресу из μPC |
| 7       | 1     | Защёлкнуть R1                        |
| 8       | 1     | Защёлкнуть R2                        |
| 9       | 1     | Защёлкнуть R3                        |
| 10-11   | 00    | Значение R1 в первый операнд ALU     |
| 10-11   | 01    | Значение R2 в первый операнд ALU     |
| 10-11   | 10    | Значение R3 в первый операнд ALU     |
| 12-13   | 00    | Значение R1 в второй операнд ALU     |
| 12-13   | 01    | Значение R2 в второй операнд ALU     |
| 12-13   | 10    | Значение R3 в второй операнд ALU     |
| 12-13   | 11    | Значение OP в второй операнд ALU     |
| 14-16   | 000    | Операция сложения в ALU              |
| 14-16   | 001    | Операция вычитания в ALU             |
| 14-16   | 010    | Операция получения остатка от деления в ALU |
| 14-16   | 011    | Операция деления в ALU               |
| 14-16   | 100    | Операция умножения в ALU               |
| 14-16   | 101    | Операция инкремента первого операнда в ALU               |
| 14-16   | 110    | Операция декремента первого операнда в ALU               |
| 17      | 1     | Начать декодировать инструкцию       |
| 18      | 0     | operand -> AR                        |
| 18      | 1     | MUX2 -> AR                           |
| 19      | 1     | Защёлкнуть AR                        |
| 20      | 1     | Чтение из памяти                     |
| 21      | 1     | Запись в память                      |
| 22      | 1     | Вывод через порт указанный в OR      |
| 23      | 1     | Добавить значение в выходной буфер   |
| 24      | 1     | Чение через порт указанный в OR      |
| 25      | 1     | Следующее значение входного буфреа   |
| 26      | 1     | Защёлкнуть значение в DR             |
| 27-28   | 00    | Значение R1 на выход MUX2            |
| 27-28   | 01    | Значение R2 на выход MUX2            |
| 27-28   | 10    | Значение R3 на выход MUX2            |
| 29-31   | 000   | Результат ALU на выход MUX1          |
| 29-31   | 001   | OR на выход MUX1                     |
| 29-31   | 010   | input buffer на выход MUX1           |
| 29-31   | 011   | DR на выход MUX1                     |
| 29-31   | 100   | Выход MUX2 на выход MUX1             |
| 32      | 1     | Защёлкнуть значение в OR             |

#### Инструкции декодированные в микропрограммы:

